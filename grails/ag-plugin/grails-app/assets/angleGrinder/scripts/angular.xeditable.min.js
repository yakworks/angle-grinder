angular.module("xeditable", []).value("editableOptions", {
    "theme": "default",
    "icon_set": "default",
    "buttons": "right",
    "blurElem": "cancel",
    "blurForm": "ignore",
    "activate": "focus",
    "isDisabled": false,
    "activationEvent": "click",
    "submitButtonTitle": "Submit",
    "submitButtonAriaLabel": "Submit",
    "cancelButtonTitle": "Cancel",
    "cancelButtonAriaLabel": "Cancel",
    "clearButtonTitle": "Clear",
    "clearButtonAriaLabel": "Clear",
    "displayClearButton": false
});

angular.module("xeditable").directive("editableBsdate", [ "editableDirectiveFactory", "$injector", "$parse", function(editableDirectiveFactory, $injector, $parse) {
    uibDatepickerConfig = $injector.get("uibDatepickerConfig");
    uibDatepickerPopupConfig = $injector.get("uibDatepickerPopupConfig");
    var popupAttrNames = [ [ "eIsOpen", "is-open" ], [ "eDateDisabled", "date-disabled" ], [ "eDatepickerPopup", "uib-datepicker-popup" ], [ "eShowButtonBar", "show-button-bar" ], [ "eCurrentText", "current-text" ], [ "eClearText", "clear-text" ], [ "eCloseText", "close-text" ], [ "eCloseOnDateSelection", "close-on-date-selection" ], [ "eDatePickerAppendToBody", "datepicker-append-to-body" ], [ "eOnOpenFocus", "on-open-focus" ], [ "eName", "name" ], [ "eDateDisabled", "date-disabled" ] ];
    var dateOptionsNames = [ [ "eFormatDay", "formatDay" ], [ "eFormatMonth", "formatMonth" ], [ "eFormatYear", "formatYear" ], [ "eFormatDayHeader", "formatDayHeader" ], [ "eFormatDayTitle", "formatDayTitle" ], [ "eFormatMonthTitle", "formatMonthTitle" ], [ "eMaxMode", "maxMode" ], [ "eMinMode", "minMode" ], [ "eDatepickerMode", "datepickerMode" ] ];
    return editableDirectiveFactory({
        "directiveName": "editableBsdate",
        "inputTpl": "<div></div>",
        "render": function() {
            this.parent.render.call(this);
            var attrs = this.attrs;
            var scope = this.scope;
            var inputDatePicker = angular.element('<input type="text" class="form-control" ng-model="$parent.$data"/>');
            inputDatePicker.attr("uib-datepicker-popup", attrs.eDatepickerPopupXEditable || uibDatepickerPopupConfig.datepickerPopup);
            inputDatePicker.attr("year-range", attrs.eYearRange || 20);
            inputDatePicker.attr("ng-readonly", attrs.eReadonly || false);
            for (var i = popupAttrNames.length - 1; i >= 0; i--) {
                var popupAttr = attrs[popupAttrNames[i][0]];
                if (typeof popupAttr !== "undefined") {
                    inputDatePicker.attr(popupAttrNames[i][1], popupAttr);
                }
            }
            if (attrs.eNgChange) {
                inputDatePicker.attr("ng-change", attrs.eNgChange);
                this.inputEl.removeAttr("ng-change");
            }
            if (attrs.eStyle) {
                inputDatePicker.attr("style", attrs.eStyle);
                this.inputEl.removeAttr("style");
            }
            var dateOptions = {
                "maxDate": scope.$eval(attrs.eMaxDate) || uibDatepickerConfig.maxDate,
                "minDate": scope.$eval(attrs.eMinDate) || uibDatepickerConfig.minDate,
                "showWeeks": attrs.eShowWeeks ? attrs.eShowWeeks.toLowerCase() === "true" : uibDatepickerConfig.showWeeks,
                "startingDay": attrs.eStartingDay || 0,
                "initDate": scope.$eval(attrs.eInitDate) || new Date()
            };
            if (attrs.eDatepickerOptions) {
                var eDatepickerOptions = $parse(attrs.eDatepickerOptions)(scope);
                angular.extend(dateOptions, eDatepickerOptions);
            }
            for (var z = dateOptionsNames.length - 1; z >= 0; z--) {
                var doAttr = attrs[dateOptionsNames[z][0]];
                if (typeof doAttr !== "undefined") {
                    dateOptions[dateOptionsNames[z][1]] = doAttr;
                }
            }
            scope.dateOptions = dateOptions;
            var showCalendarButton = angular.isDefined(attrs.eShowCalendarButton) ? attrs.eShowCalendarButton : "true";
            if (showCalendarButton === "true") {
                var buttonDatePicker = angular.element('<button type="button" class="btn btn-default"><i class="glyphicon glyphicon-calendar"></i></button>');
                var buttonWrapper = angular.element('<span class="input-group-btn"></span>');
                buttonDatePicker.attr("ng-click", attrs.eNgClick);
                buttonWrapper.append(buttonDatePicker);
                this.inputEl.append(buttonWrapper);
            } else {
                inputDatePicker.attr("ng-click", attrs.eNgClick);
            }
            inputDatePicker.attr("datepicker-options", "dateOptions");
            this.inputEl.prepend(inputDatePicker);
            this.inputEl.removeAttr("class");
            this.inputEl.removeAttr("ng-click");
            this.inputEl.removeAttr("is-open");
            this.inputEl.removeAttr("init-date");
            this.inputEl.removeAttr("datepicker-popup");
            this.inputEl.removeAttr("required");
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("date-picker-append-to-body");
            this.inputEl.removeAttr("name");
            this.inputEl.attr("class", "input-group");
        }
    });
} ]);

angular.module("xeditable").directive("editableBstime", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableBstime",
        "inputTpl": "<uib-timepicker></uib-timepicker>",
        "render": function() {
            this.parent.render.call(this);
            var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');
            div.attr("ng-model", this.inputEl.attr("ng-model"));
            this.inputEl.removeAttr("ng-model");
            if (this.attrs.eNgChange) {
                div.attr("ng-change", this.inputEl.attr("ng-change"));
                this.inputEl.removeAttr("ng-change");
            }
            this.inputEl.wrap(div);
        }
    });
} ]);

angular.module("xeditable").directive("editableCheckbox", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableCheckbox",
        "inputTpl": '<input type="checkbox">',
        "render": function() {
            this.parent.render.call(this);
            if (this.attrs.eTitle) {
                this.inputEl.wrap("<label></label>");
                this.inputEl.parent().append("<span>" + this.attrs.eTitle + "</span>");
            }
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableChecklist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        "directiveName": "editableChecklist",
        "inputTpl": "<span></span>",
        "useCopy": true,
        "render": function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var ngChangeHtml = "";
            var ngChecklistComparatorHtml = "";
            if (this.attrs.eNgChange) {
                ngChangeHtml = ' ng-change="' + this.attrs.eNgChange + '"';
            }
            if (this.attrs.eChecklistComparator) {
                ngChecklistComparatorHtml = ' checklist-comparator="' + this.attrs.eChecklistComparator + '"';
            }
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="checkbox" checklist-model="$parent.$parent.$data" checklist-value="' + parsed.locals.valueFn + '"' + ngChangeHtml + ngChecklistComparatorHtml + ">" + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.removeAttr("ng-change");
            this.inputEl.removeAttr("checklist-comparator");
            this.inputEl.html(html);
        }
    });
} ]);

angular.module("xeditable").directive("editableCombodate", [ "editableDirectiveFactory", "editableCombodate", function(editableDirectiveFactory, editableCombodate) {
    return editableDirectiveFactory({
        "directiveName": "editableCombodate",
        "inputTpl": '<input type="text">',
        "render": function() {
            this.parent.render.call(this);
            var options = {
                "value": new Date(this.scope.$data)
            };
            var self = this;
            angular.forEach([ "format", "template", "minYear", "maxYear", "yearDescending", "minuteStep", "secondStep", "firstItem", "errorClass", "customClass", "roundTime", "smartDays" ], function(name) {
                var attrName = "e" + name.charAt(0).toUpperCase() + name.slice(1);
                if (attrName in self.attrs) {
                    if (name == "minYear" || name == "maxYear" || name == "minuteStep" || name == "secondStep") {
                        options[name] = parseInt(self.attrs[attrName], 10);
                    } else {
                        options[name] = self.attrs[attrName];
                    }
                }
            });
            var combodate = editableCombodate.getInstance(this.inputEl, options);
            combodate.$widget.find("select").bind("change", function(e) {
                self.scope.$data = new Date(combodate.getValue()).toISOString();
            });
        }
    });
} ]);

(function() {
    var camelCase = function(dashDelimitedString) {
        return dashDelimitedString.toLowerCase().replace(/-(.)/g, function(match, word) {
            return word.toUpperCase();
        });
    };
    var types = "text|password|email|tel|number|url|search|color|date|datetime|datetime-local|time|month|week|file".split("|");
    angular.forEach(types, function(type) {
        var directiveName = camelCase("editable" + "-" + type);
        angular.module("xeditable").directive(directiveName, [ "editableDirectiveFactory", function(editableDirectiveFactory) {
            return editableDirectiveFactory({
                "directiveName": directiveName,
                "inputTpl": '<input type="' + type + '">',
                "render": function() {
                    this.parent.render.call(this);
                    if (this.attrs.eInputgroupleft || this.attrs.eInputgroupright) {
                        this.inputEl.wrap('<div class="input-group"></div>');
                        if (this.attrs.eInputgroupleft) {
                            var inputGroupLeft = angular.element('<span class="input-group-addon">' + this.attrs.eInputgroupleft + "</span>");
                            this.inputEl.parent().prepend(inputGroupLeft);
                        }
                        if (this.attrs.eInputgroupright) {
                            var inputGroupRight = angular.element('<span class="input-group-addon">' + this.attrs.eInputgroupright + "</span>");
                            this.inputEl.parent().append(inputGroupRight);
                        }
                    }
                    if (this.attrs.eLabel) {
                        var label = angular.element("<label>" + this.attrs.eLabel + "</label>");
                        if (this.attrs.eInputgroupleft || this.attrs.eInputgroupright) {
                            this.inputEl.parent().parent().prepend(label);
                        } else {
                            this.inputEl.parent().prepend(label);
                        }
                    }
                    if (this.attrs.eFormclass) {
                        this.editorEl.addClass(this.attrs.eFormclass);
                    }
                },
                "autosubmit": function() {
                    var self = this;
                    self.inputEl.bind("keydown", function(e) {
                        if (e.keyCode === 9) {
                            self.scope.$apply(function() {
                                self.scope.$form.$submit();
                            });
                        }
                    });
                }
            });
        } ]);
    });
    angular.module("xeditable").directive("editableRange", [ "editableDirectiveFactory", "$interpolate", function(editableDirectiveFactory, $interpolate) {
        return editableDirectiveFactory({
            "directiveName": "editableRange",
            "inputTpl": '<input type="range" id="range" name="range">',
            "render": function() {
                this.parent.render.call(this);
                this.inputEl.after("<output>" + $interpolate.startSymbol() + "$data" + $interpolate.endSymbol() + "</output>");
            }
        });
    } ]);
})();

angular.module("xeditable").directive("editableTagsInput", [ "editableDirectiveFactory", "editableUtils", function(editableDirectiveFactory, editableUtils) {
    var dir = editableDirectiveFactory({
        "directiveName": "editableTagsInput",
        "inputTpl": "<tags-input></tags-input>",
        "render": function() {
            this.parent.render.call(this);
            this.inputEl.append(editableUtils.rename("auto-complete", this.attrs.$autoCompleteElement));
            this.inputEl.removeAttr("ng-model");
            this.inputEl.attr("ng-model", "$parent.$data");
        }
    });
    var linkOrg = dir.link;
    dir.link = function(scope, el, attrs, ctrl) {
        var autoCompleteEl = el.find("editable-tags-input-auto-complete");
        attrs.$autoCompleteElement = autoCompleteEl.clone();
        autoCompleteEl.remove();
        return linkOrg(scope, el, attrs, ctrl);
    };
    return dir;
} ]);

angular.module("xeditable").directive("editableRadiolist", [ "editableDirectiveFactory", "editableNgOptionsParser", "$interpolate", function(editableDirectiveFactory, editableNgOptionsParser, $interpolate) {
    return editableDirectiveFactory({
        "directiveName": "editableRadiolist",
        "inputTpl": "<span></span>",
        "render": function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var ngChangeHtml = "";
            if (this.attrs.eNgChange) {
                ngChangeHtml = 'ng-change="' + this.attrs.eNgChange + '"';
            }
            var html = '<label data-ng-repeat="' + parsed.ngRepeat + '">' + '<input type="radio" data-ng-disabled="::' + this.attrs.eNgDisabled + '" data-ng-model="$parent.$parent.$data" data-ng-value="' + $interpolate.startSymbol() + "::" + parsed.locals.valueFn + $interpolate.endSymbol() + '"' + ngChangeHtml + ">" + '<span data-ng-bind="::' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.removeAttr("ng-change");
            this.inputEl.html(html);
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableSelect", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableSelect",
        "inputTpl": "<select></select>",
        "render": function() {
            this.parent.render.call(this);
            if (this.attrs.ePlaceholder) {
                var placeholder = angular.element('<option value="">' + this.attrs.ePlaceholder + "</option>");
                this.inputEl.append(placeholder);
            }
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("change", function() {
                self.scope.$apply(function() {
                    self.scope.$form.$submit();
                });
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableTextarea", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableTextarea",
        "inputTpl": "<textarea></textarea>",
        "addListeners": function() {
            var self = this;
            self.parent.addListeners.call(self);
            if (self.single && self.buttons !== "no") {
                self.autosubmit();
            }
        },
        "autosubmit": function() {
            var self = this;
            self.inputEl.bind("keydown", function(e) {
                if (self.attrs.submitOnEnter) {
                    if (e.keyCode === 13 && !e.shiftKey) {
                        self.scope.$apply(function() {
                            self.scope.$form.$submit();
                        });
                    }
                } else if ((e.ctrlKey || e.metaKey) && e.keyCode === 13) {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableUidate", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        "directiveName": "editableUidate",
        "inputTpl": '<input class="form-control" />',
        "render": function() {
            this.parent.render.call(this);
            this.inputEl.attr("ui-date", this.attrs.eUiDate);
            this.inputEl.attr("placeholder", this.attrs.ePlaceholder);
        }
    });
} ]);

angular.module("xeditable").directive("editableUiSelect", [ "editableDirectiveFactory", "editableUtils", function(editableDirectiveFactory, editableUtils) {
    var dir = editableDirectiveFactory({
        "directiveName": "editableUiSelect",
        "inputTpl": "<ui-select></ui-select>",
        "render": function() {
            this.parent.render.call(this);
            this.inputEl.append(editableUtils.rename("ui-select-match", this.attrs.$matchElement));
            this.inputEl.append(editableUtils.rename("ui-select-choices", this.attrs.$choicesElement));
            this.inputEl.removeAttr("ng-model");
            this.inputEl.attr("ng-model", "$parent.$parent.$data");
        }
    });
    var linkOrg = dir.link;
    dir.link = function(scope, el, attrs, ctrl) {
        var matchEl = el.find("editable-ui-select-match");
        var choicesEl = el.find("editable-ui-select-choices");
        attrs.$matchElement = matchEl.clone();
        attrs.$choicesElement = choicesEl.clone();
        matchEl.remove();
        choicesEl.remove();
        return linkOrg(scope, el, attrs, ctrl);
    };
    return dir;
} ]);

angular.module("xeditable").factory("editableController", [ "$q", "editableUtils", function($q, editableUtils) {
    EditableController.$inject = [ "$scope", "$attrs", "$element", "$parse", "editableThemes", "editableIcons", "editableOptions", "$rootScope", "$compile", "$q" ];
    function EditableController($scope, $attrs, $element, $parse, editableThemes, editableIcons, editableOptions, $rootScope, $compile, $q) {
        var valueGetter;
        var inWaiting;
        var self = this;
        self.scope = $scope;
        self.elem = $element;
        self.attrs = $attrs;
        self.inputEl = null;
        self.editorEl = null;
        self.single = true;
        self.error = "";
        self.theme = editableThemes[$attrs.editableTheme] || editableThemes[editableOptions.theme] || editableThemes["default"];
        self.parent = {};
        var theme_name = $attrs.editableTheme || editableOptions.theme || "default";
        var icon_set_option = $attrs.editableIconSet || editableOptions.icon_set;
        self.icon_set = icon_set_option === "default" ? editableIcons.default[theme_name] : editableIcons.external[icon_set_option];
        self.inputTpl = "";
        self.directiveName = "";
        self.useCopy = false;
        self.single = null;
        self.buttons = "right";
        self.init = function(single) {
            self.single = single;
            self.name = $attrs.eName || $attrs[self.directiveName];
            if ($attrs[self.directiveName]) {
                valueGetter = $parse($attrs[self.directiveName]);
            } else {
                throw "You should provide value for `" + self.directiveName + "` in editable element!";
            }
            if (!self.single) {
                self.buttons = "no";
            } else {
                self.buttons = self.attrs.buttons || editableOptions.buttons;
            }
            if ($attrs.eName) {
                self.scope.$watch("$data", function(newVal) {
                    self.scope.$form.$data[$attrs.eName] = newVal;
                });
            }
            if ($attrs.onshow) {
                self.onshow = function() {
                    return self.catchError($parse($attrs.onshow)($scope));
                };
            }
            if ($attrs.onhide) {
                self.onhide = function() {
                    return $parse($attrs.onhide)($scope);
                };
            }
            if ($attrs.oncancel) {
                self.oncancel = function() {
                    return $parse($attrs.oncancel)($scope);
                };
            }
            if ($attrs.onbeforesave) {
                self.onbeforesave = function() {
                    return self.catchError($parse($attrs.onbeforesave)($scope));
                };
            }
            if ($attrs.onaftersave) {
                self.onaftersave = function() {
                    return self.catchError($parse($attrs.onaftersave)($scope));
                };
            }
            $scope.$parent.$watch($attrs[self.directiveName], function(newVal, oldVal) {
                self.setLocalValue();
                self.handleEmpty();
            });
        };
        self.render = function() {
            var theme = self.theme;
            self.inputEl = angular.element(self.inputTpl);
            self.controlsEl = angular.element(theme.controlsTpl);
            self.controlsEl.append(self.inputEl);
            if (self.buttons !== "no") {
                self.buttonsEl = angular.element(theme.buttonsTpl);
                self.submitEl = angular.element(theme.submitTpl);
                self.resetEl = angular.element(theme.resetTpl);
                self.cancelEl = angular.element(theme.cancelTpl);
                self.submitEl.attr("title", editableOptions.submitButtonTitle);
                self.submitEl.attr("aria-label", editableOptions.submitButtonAriaLabel);
                self.cancelEl.attr("title", editableOptions.cancelButtonTitle);
                self.cancelEl.attr("aria-label", editableOptions.cancelButtonAriaLabel);
                self.resetEl.attr("title", editableOptions.clearButtonTitle);
                self.resetEl.attr("aria-label", editableOptions.clearButtonAriaLabel);
                if (self.icon_set) {
                    self.submitEl.find("span").addClass(self.icon_set.ok);
                    self.cancelEl.find("span").addClass(self.icon_set.cancel);
                    self.resetEl.find("span").addClass(self.icon_set.clear);
                }
                self.buttonsEl.append(self.submitEl).append(self.cancelEl);
                if (editableOptions.displayClearButton) {
                    self.buttonsEl.append(self.resetEl);
                }
                self.controlsEl.append(self.buttonsEl);
                self.inputEl.addClass("editable-has-buttons");
            }
            self.errorEl = angular.element(theme.errorTpl);
            self.controlsEl.append(self.errorEl);
            self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
            self.editorEl.append(self.controlsEl);
            for (var k in $attrs.$attr) {
                if (k.length <= 1) {
                    continue;
                }
                var transferAttr = false;
                var nextLetter = k.substring(1, 2);
                if (k.substring(0, 1) === "e" && nextLetter === nextLetter.toUpperCase()) {
                    transferAttr = k.substring(1);
                } else {
                    continue;
                }
                if (transferAttr === "Form" || transferAttr === "NgSubmit") {
                    continue;
                }
                var firstLetter = transferAttr.substring(0, 1);
                var secondLetter = transferAttr.substring(1, 2);
                if (secondLetter === secondLetter.toUpperCase() && firstLetter === firstLetter.toUpperCase()) {
                    transferAttr = firstLetter.toLowerCase() + "-" + editableUtils.camelToDash(transferAttr.substring(1));
                } else {
                    transferAttr = firstLetter.toLowerCase() + editableUtils.camelToDash(transferAttr.substring(1));
                }
                var attrValue = transferAttr !== "value" && $attrs[k] === "" ? transferAttr : $attrs[k];
                self.inputEl.attr(transferAttr, attrValue);
            }
            self.inputEl.addClass("editable-input");
            self.inputEl.attr("ng-model", "$parent.$data");
            self.editorEl.addClass(editableUtils.camelToDash(self.directiveName));
            if (self.single) {
                self.editorEl.attr("editable-form", "$form");
                self.editorEl.attr("blur", self.attrs.blur || (self.buttons === "no" ? "cancel" : editableOptions.blurElem));
            }
            if (angular.isFunction(theme.postrender)) {
                theme.postrender.call(self);
            }
        };
        self.setLocalValue = function() {
            self.scope.$data = self.useCopy ? angular.copy(valueGetter($scope.$parent)) : valueGetter($scope.$parent);
        };
        var newScope = null;
        self.show = function() {
            self.setLocalValue();
            self.render();
            $element.after(self.editorEl);
            newScope = $scope.$new();
            $compile(self.editorEl)(newScope);
            self.addListeners();
            $element.addClass("editable-hide");
            return self.onshow();
        };
        self.hide = function() {
            newScope.$destroy();
            self.controlsEl.remove();
            self.editorEl.remove();
            $element.removeClass("editable-hide");
            return self.onhide();
        };
        self.cancel = function() {
            self.oncancel();
        };
        self.addListeners = function() {
            self.inputEl.bind("keyup", function(e) {
                if (!self.single) {
                    return;
                }
                switch (e.keyCode) {
                  case 27:
                    self.scope.$apply(function() {
                        self.scope.$form.$cancel();
                    });
                    break;
                }
            });
            if (self.single && self.buttons === "no") {
                self.autosubmit();
            }
            self.editorEl.bind("click", function(e) {
                if (e.which && e.which !== 1) {
                    return;
                }
                if (self.scope.$form.$visible) {
                    self.scope.$form._clicked = true;
                }
            });
        };
        self.setWaiting = function(value) {
            if (value) {
                inWaiting = !self.inputEl.attr("disabled") && !self.inputEl.attr("ng-disabled") && !self.inputEl.attr("ng-enabled");
                if (inWaiting) {
                    self.inputEl.attr("disabled", "disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").attr("disabled", "disabled");
                    }
                }
            } else {
                if (inWaiting) {
                    self.inputEl.removeAttr("disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").removeAttr("disabled");
                    }
                }
            }
        };
        self.activate = function(start, end) {
            setTimeout(function() {
                var el = self.inputEl[0];
                if (editableOptions.activate === "focus" && el.focus) {
                    if (start !== undefined && start !== "" && el.setSelectionRange) {
                        end = end || start;
                        el.onfocus = function() {
                            setTimeout(function() {
                                try {
                                    this.setSelectionRange(start, end);
                                } catch (e) {}
                            }.bind(this));
                        };
                    }
                    if (self.directiveName == "editableRadiolist" || self.directiveName == "editableChecklist" || self.directiveName == "editableBsdate" || self.directiveName == "editableTagsInput") {
                        el.querySelector(".ng-pristine").focus();
                    } else {
                        el.focus();
                    }
                } else if (editableOptions.activate === "select") {
                    if (el.select) {
                        el.select();
                    } else if (el.focus) {
                        el.focus();
                    }
                }
            }, 0);
        };
        self.setError = function(msg) {
            if (!angular.isObject(msg)) {
                $scope.$error = msg;
                self.error = msg;
            }
        };
        self.catchError = function(result, noPromise) {
            if (angular.isObject(result) && noPromise !== true) {
                $q.when(result).then(angular.bind(this, function(r) {
                    this.catchError(r, true);
                }), angular.bind(this, function(r) {
                    this.catchError(r, true);
                }));
            } else if (noPromise && angular.isObject(result) && result.status && result.status !== 200 && result.data && angular.isString(result.data)) {
                this.setError(result.data);
                result = result.data;
            } else if (angular.isString(result)) {
                this.setError(result);
            }
            return result;
        };
        self.save = function() {
            valueGetter.assign($scope.$parent, self.useCopy ? angular.copy(self.scope.$data) : self.scope.$data);
        };
        self.handleEmpty = function() {
            var val = valueGetter($scope.$parent);
            var isEmpty = val === null || val === undefined || val === "" || angular.isArray(val) && val.length === 0;
            $element.toggleClass("editable-empty", isEmpty);
        };
        self.autosubmit = angular.noop;
        self.onshow = angular.noop;
        self.onhide = angular.noop;
        self.oncancel = angular.noop;
        self.onbeforesave = angular.noop;
        self.onaftersave = angular.noop;
    }
    return EditableController;
} ]);

angular.module("xeditable").factory("editableDirectiveFactory", [ "$parse", "$compile", "editableThemes", "$rootScope", "$document", "editableController", "editableFormController", "editableOptions", function($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController, editableOptions) {
    return function(overwrites) {
        return {
            "restrict": "A",
            "scope": true,
            "require": [ overwrites.directiveName, "?^form" ],
            "controller": editableController,
            "link": function(scope, elem, attrs, ctrl) {
                var eCtrl = ctrl[0];
                var eFormCtrl;
                var hasForm = false;
                if (ctrl[1]) {
                    eFormCtrl = ctrl[1];
                    hasForm = attrs.eSingle === undefined;
                } else if (attrs.eForm) {
                    var getter = $parse(attrs.eForm)(scope);
                    if (getter) {
                        eFormCtrl = getter;
                        hasForm = true;
                    } else if (elem && typeof elem.parents === "function" && elem.parents().last().find("form[name=" + attrs.eForm + "]").length) {
                        eFormCtrl = null;
                        hasForm = true;
                    } else {
                        for (var i = 0; i < $document[0].forms.length; i++) {
                            if ($document[0].forms[i].name === attrs.eForm) {
                                eFormCtrl = null;
                                hasForm = true;
                                break;
                            }
                        }
                    }
                }
                angular.forEach(overwrites, function(v, k) {
                    if (eCtrl[k] !== undefined) {
                        eCtrl.parent[k] = eCtrl[k];
                    }
                });
                angular.extend(eCtrl, overwrites);
                var is_disabled = function() {
                    return angular.isDefined(attrs.editDisabled) ? scope.$eval(attrs.editDisabled) : editableOptions.isDisabled;
                };
                eCtrl.init(!hasForm);
                scope.$editable = eCtrl;
                elem.addClass("editable");
                if (hasForm) {
                    if (eFormCtrl) {
                        scope.$form = eFormCtrl;
                        if (!scope.$form.$addEditable) {
                            throw "Form with editable elements should have `editable-form` attribute.";
                        }
                        scope.$form.$addEditable(eCtrl);
                    } else {
                        $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
                        $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
                        $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
                        scope.$form = null;
                    }
                } else {
                    scope.$form = editableFormController();
                    scope.$form.$addEditable(eCtrl);
                    if (attrs.eForm) {
                        ($parse(attrs.eForm).assign || angular.noop)(scope.$parent, scope.$form);
                    }
                    if (!attrs.eForm || attrs.eClickable) {
                        elem.addClass("editable-click");
                        elem.bind(editableOptions.activationEvent, function(e) {
                            e.preventDefault();
                            e.editable = eCtrl;
                            if (!is_disabled()) {
                                scope.$apply(function() {
                                    scope.$form.$show();
                                });
                            }
                        });
                    }
                }
            }
        };
    };
} ]);

angular.module("xeditable").factory("editableFormController", [ "$parse", "$document", "$rootScope", "editablePromiseCollection", "editableUtils", function($parse, $document, $rootScope, editablePromiseCollection, editableUtils) {
    var shown = [];
    var isSelfOrDescendant = function(parent, child) {
        if (child == parent) {
            return true;
        }
        var node = child.parentNode;
        while (node !== null) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    var isBlur = function(shown, event) {
        var isBlur = true;
        var editables = shown.$editables;
        angular.forEach(editables, function(v) {
            var element = v.editorEl[0];
            if (isSelfOrDescendant(element, event.target)) isBlur = false;
        });
        return isBlur;
    };
    $document.bind("click", function(e) {
        if (e.which && e.which !== 1) {
            return;
        }
        var toCancel = [];
        var toSubmit = [];
        for (var i = 0; i < shown.length; i++) {
            if (shown[i]._clicked) {
                shown[i]._clicked = false;
                continue;
            }
            if (shown[i].$waiting) {
                continue;
            }
            if (shown[i]._blur === "cancel" && isBlur(shown[i], e)) {
                toCancel.push(shown[i]);
            }
            if (shown[i]._blur === "submit" && isBlur(shown[i], e)) {
                toSubmit.push(shown[i]);
            }
        }
        if (toCancel.length || toSubmit.length) {
            $rootScope.$apply(function() {
                angular.forEach(toCancel, function(v) {
                    v.$cancel();
                });
                angular.forEach(toSubmit, function(v) {
                    v.$submit();
                });
            });
        }
    });
    $rootScope.$on("closeEdit", function() {
        for (var i = 0; i < shown.length; i++) {
            shown[i].$hide();
        }
    });
    var base = {
        "$addEditable": function(editable) {
            this.$editables.push(editable);
            editable.elem.bind("$destroy", angular.bind(this, this.$removeEditable, editable));
            if (!editable.scope.$form) {
                editable.scope.$form = this;
            }
            if (this.$visible) {
                editable.catchError(editable.show());
            }
            editable.catchError(editable.setWaiting(this.$waiting));
        },
        "$removeEditable": function(editable) {
            for (var i = 0; i < this.$editables.length; i++) {
                if (this.$editables[i] === editable) {
                    this.$editables.splice(i, 1);
                    return;
                }
            }
        },
        "$show": function() {
            if (this.$visible) {
                return;
            }
            this.$visible = true;
            var pc = editablePromiseCollection();
            pc.when(this.$onshow());
            this.$setError(null, "");
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.show());
            });
            pc.then({
                "onWait": angular.bind(this, this.$setWaiting),
                "onTrue": angular.bind(this, this.$activate),
                "onFalse": angular.bind(this, this.$activate),
                "onString": angular.bind(this, this.$activate)
            });
            setTimeout(angular.bind(this, function() {
                this._clicked = false;
                if (editableUtils.indexOf(shown, this) === -1) {
                    shown.push(this);
                }
            }), 0);
        },
        "$activate": function(name) {
            var i, selectionStart, selectionEnd;
            if (this.$editables.length) {
                if (angular.isString(name)) {
                    for (i = 0; i < this.$editables.length; i++) {
                        if (this.$editables[i].name === name) {
                            this.$editables[i].activate();
                            return;
                        }
                    }
                }
                for (i = 0; i < this.$editables.length; i++) {
                    if (this.$editables[i].error) {
                        this.$editables[i].activate();
                        return;
                    }
                }
                selectionStart = this.$editables[0].elem[0].selectionStart ? this.$editables[0].elem[0].selectionStart : this.$editables[0].elem[0].text ? this.$editables[0].elem[0].text.length : 0;
                selectionEnd = this.$editables[0].elem[0].selectionEnd ? this.$editables[0].elem[0].selectionEnd : this.$editables[0].elem[0].text ? this.$editables[0].elem[0].text.length : 0;
                this.$editables[0].activate(selectionStart, selectionEnd);
            }
        },
        "$hide": function() {
            if (!this.$visible) {
                return;
            }
            this.$visible = false;
            this.$onhide();
            angular.forEach(this.$editables, function(editable) {
                editable.hide();
            });
            editableUtils.arrayRemove(shown, this);
        },
        "$cancel": function() {
            if (!this.$visible) {
                return;
            }
            this.$oncancel();
            angular.forEach(this.$editables, function(editable) {
                editable.cancel();
            });
            this.$hide();
        },
        "$setWaiting": function(value) {
            this.$waiting = !!value;
            angular.forEach(this.$editables, function(editable) {
                editable.setWaiting(!!value);
            });
        },
        "$setError": function(name, msg) {
            angular.forEach(this.$editables, function(editable) {
                if (!name || editable.name === name) {
                    editable.setError(msg);
                }
            });
        },
        "$submit": function() {
            if (this.$waiting) {
                return;
            }
            this.$setError(null, "");
            var pc = editablePromiseCollection();
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onbeforesave());
            });
            pc.then({
                "onWait": angular.bind(this, this.$setWaiting),
                "onTrue": angular.bind(this, checkSelf, true),
                "onFalse": angular.bind(this, checkSelf, false),
                "onString": angular.bind(this, this.$activate)
            });
            function checkSelf(childrenTrue) {
                var pc = editablePromiseCollection();
                pc.when(this.$onbeforesave());
                pc.then({
                    "onWait": angular.bind(this, this.$setWaiting),
                    "onTrue": childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide),
                    "onFalse": angular.bind(this, this.$hide),
                    "onString": angular.bind(this, this.$activate)
                });
            }
        },
        "$save": function() {
            angular.forEach(this.$editables, function(editable) {
                editable.save();
            });
            var pc = editablePromiseCollection();
            pc.when(this.$onaftersave());
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onaftersave());
            });
            pc.then({
                "onWait": angular.bind(this, this.$setWaiting),
                "onTrue": angular.bind(this, this.$hide),
                "onFalse": angular.bind(this, this.$hide),
                "onString": angular.bind(this, this.$activate)
            });
        },
        "$onshow": angular.noop,
        "$oncancel": angular.noop,
        "$onhide": angular.noop,
        "$onbeforesave": angular.noop,
        "$onaftersave": angular.noop
    };
    return function() {
        return angular.extend({
            "$editables": [],
            "$visible": false,
            "$waiting": false,
            "$data": {},
            "_clicked": false,
            "_blur": null
        }, base);
    };
} ]);

angular.module("xeditable").directive("editableForm", [ "$rootScope", "$parse", "editableFormController", "editableOptions", function($rootScope, $parse, editableFormController, editableOptions) {
    return {
        "restrict": "A",
        "require": [ "form" ],
        "compile": function() {
            return {
                "pre": function(scope, elem, attrs, ctrl) {
                    var form = ctrl[0];
                    var eForm;
                    if (attrs.editableForm) {
                        if (scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                            eForm = scope[attrs.editableForm];
                            angular.extend(form, eForm);
                        } else {
                            eForm = editableFormController();
                            scope[attrs.editableForm] = eForm;
                            angular.extend(eForm, form);
                        }
                    } else {
                        eForm = editableFormController();
                        angular.extend(form, eForm);
                    }
                    var buf = $rootScope.$$editableBuffer;
                    var name = form.$name;
                    if (name && buf && buf[name]) {
                        angular.forEach(buf[name], function(editable) {
                            eForm.$addEditable(editable);
                        });
                        delete buf[name];
                    }
                },
                "post": function(scope, elem, attrs, ctrl) {
                    var eForm;
                    if (attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                        eForm = scope[attrs.editableForm];
                    } else {
                        eForm = ctrl[0];
                    }
                    if (attrs.onshow) {
                        eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
                    }
                    if (attrs.onhide) {
                        eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
                    }
                    if (attrs.oncancel) {
                        eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
                    }
                    if (attrs.shown && $parse(attrs.shown)(scope)) {
                        eForm.$show();
                    }
                    eForm._blur = attrs.blur || editableOptions.blurForm;
                    if (!attrs.ngSubmit && !attrs.submit) {
                        if (attrs.onbeforesave) {
                            eForm.$onbeforesave = function() {
                                return $parse(attrs.onbeforesave)(scope, {
                                    "$data": eForm.$data
                                });
                            };
                        }
                        if (attrs.onaftersave) {
                            eForm.$onaftersave = function() {
                                return $parse(attrs.onaftersave)(scope, {
                                    "$data": eForm.$data
                                });
                            };
                        }
                        elem.bind("submit", function(event) {
                            event.preventDefault();
                            scope.$apply(function() {
                                eForm.$submit();
                            });
                        });
                    }
                    elem.bind("click", function(e) {
                        if (e.which && e.which !== 1) {
                            return;
                        }
                        if (eForm.$visible) {
                            eForm._clicked = true;
                        }
                    });
                }
            };
        }
    };
} ]);

angular.module("xeditable").factory("editablePromiseCollection", [ "$q", function($q) {
    function promiseCollection() {
        return {
            "promises": [],
            "hasFalse": false,
            "hasString": false,
            "when": function(result, noPromise) {
                if (result === false) {
                    this.hasFalse = true;
                } else if (!noPromise && angular.isObject(result)) {
                    this.promises.push($q.when(result));
                } else if (angular.isString(result)) {
                    this.hasString = true;
                } else {
                    return;
                }
            },
            "then": function(callbacks) {
                callbacks = callbacks || {};
                var onTrue = callbacks.onTrue || angular.noop;
                var onFalse = callbacks.onFalse || angular.noop;
                var onString = callbacks.onString || angular.noop;
                var onWait = callbacks.onWait || angular.noop;
                var self = this;
                if (this.promises.length) {
                    onWait(true);
                    $q.all(this.promises).then(function(results) {
                        onWait(false);
                        angular.forEach(results, function(result) {
                            self.when(result, true);
                        });
                        applyCallback();
                    }, function(error) {
                        onWait(false);
                        onString();
                    });
                } else {
                    applyCallback();
                }
                function applyCallback() {
                    if (!self.hasString && !self.hasFalse) {
                        onTrue();
                    } else if (!self.hasString && self.hasFalse) {
                        onFalse();
                    } else {
                        onString();
                    }
                }
            }
        };
    }
    return promiseCollection;
} ]);

angular.module("xeditable").factory("editableUtils", [ function() {
    return {
        "indexOf": function(array, obj) {
            if (array.indexOf) return array.indexOf(obj);
            for (var i = 0; i < array.length; i++) {
                if (obj === array[i]) return i;
            }
            return -1;
        },
        "arrayRemove": function(array, value) {
            var index = this.indexOf(array, value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return value;
        },
        "camelToDash": function(str) {
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            return str.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? "-" : "") + letter.toLowerCase();
            });
        },
        "dashToCamel": function(str) {
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            return str.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, "Moz$1");
        },
        "rename": function(tag, el) {
            if (el[0] && el[0].attributes) {
                var newEl = angular.element("<" + tag + "/>");
                newEl.html(el.html());
                var attrs = el[0].attributes;
                for (var i = 0; i < attrs.length; ++i) {
                    newEl.attr(attrs.item(i).nodeName, attrs.item(i).value);
                }
                return newEl;
            }
        }
    };
} ]);

angular.module("xeditable").factory("editableNgOptionsParser", [ function() {
    var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;
    function parser(optionsExp) {
        var match;
        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
            throw "ng-options parse error";
        }
        var displayFn = match[2] || match[1], valueName = match[4] || match[6], keyName = match[5], groupByFn = match[3] || "", valueFn = match[2] ? match[1] : valueName, valuesFn = match[7], track = match[8], trackFn = track ? match[8] : null;
        var ngRepeat;
        if (keyName === undefined) {
            ngRepeat = valueName + " in " + valuesFn;
            if (track !== undefined) {
                ngRepeat += " track by " + trackFn;
            }
        } else {
            ngRepeat = "(" + keyName + ", " + valueName + ") in " + valuesFn;
        }
        return {
            "ngRepeat": ngRepeat,
            "locals": {
                "valueName": valueName,
                "keyName": keyName,
                "valueFn": valueFn,
                "displayFn": displayFn
            }
        };
    }
    return parser;
} ]);

angular.module("xeditable").factory("editableCombodate", [ function() {
    function Combodate(element, options) {
        this.$element = angular.element(element);
        if (this.$element[0].nodeName != "INPUT") {
            throw "Combodate should be applied to INPUT element";
        }
        var currentYear = new Date().getFullYear();
        this.defaults = {
            "format": "YYYY-MM-DD HH:mm",
            "template": "D / MMM / YYYY   H : mm",
            "value": null,
            "minYear": 1970,
            "maxYear": currentYear,
            "yearDescending": true,
            "minuteStep": 5,
            "secondStep": 1,
            "firstItem": "empty",
            "errorClass": null,
            "customClass": "",
            "roundTime": true,
            "smartDays": true
        };
        this.options = angular.extend({}, this.defaults, options);
        this.init();
    }
    Combodate.prototype = {
        "constructor": Combodate,
        "init": function() {
            this.map = {
                "day": [ "D", "date" ],
                "month": [ "M", "month" ],
                "year": [ "Y", "year" ],
                "hour": [ "[Hh]", "hours" ],
                "minute": [ "m", "minutes" ],
                "second": [ "s", "seconds" ],
                "ampm": [ "[Aa]", "" ]
            };
            this.$widget = angular.element('<span class="combodate"></span>').html(this.getTemplate());
            this.initCombos();
            if (this.options.smartDays) {
                var combo = this;
                this.$widget.find("select").bind("change", function(e) {
                    if (angular.element(e.target).hasClass("month") || angular.element(e.target).hasClass("year")) {
                        combo.fillCombo("day");
                    }
                });
            }
            this.$widget.find("select").css("width", "auto");
            this.$element.css("display", "none").after(this.$widget);
            this.setValue(this.$element.val() || this.options.value);
        },
        "getTemplate": function() {
            var tpl = this.options.template;
            var customClass = this.options.customClass;
            angular.forEach(this.map, function(v, k) {
                v = v[0];
                var r = new RegExp(v + "+");
                var token = v.length > 1 ? v.substring(1, 2) : v;
                tpl = tpl.replace(r, "{" + token + "}");
            });
            tpl = tpl.replace(/ /g, "&nbsp;");
            angular.forEach(this.map, function(v, k) {
                v = v[0];
                var token = v.length > 1 ? v.substring(1, 2) : v;
                tpl = tpl.replace("{" + token + "}", '<select class="' + k + " " + customClass + '"></select>');
            });
            return tpl;
        },
        "initCombos": function() {
            for (var k in this.map) {
                var c = this.$widget[0].querySelectorAll("." + k);
                this["$" + k] = c.length ? angular.element(c) : null;
                this.fillCombo(k);
            }
        },
        "fillCombo": function(k) {
            var $combo = this["$" + k];
            if (!$combo) {
                return;
            }
            var f = "fill" + k.charAt(0).toUpperCase() + k.slice(1);
            var items = this[f]();
            var value = $combo.val();
            $combo.html("");
            for (var i = 0; i < items.length; i++) {
                $combo.append('<option value="' + items[i][0] + '">' + items[i][1] + "</option>");
            }
            $combo.val(value);
        },
        "fillCommon": function(key) {
            var values = [], relTime;
            if (this.options.firstItem === "name") {
                relTime = moment.relativeTime || moment.langData()._relativeTime;
                var header = typeof relTime[key] === "function" ? relTime[key](1, true, key, false) : relTime[key];
                header = header.split(" ").reverse()[0];
                values.push([ "", header ]);
            } else if (this.options.firstItem === "empty") {
                values.push([ "", "" ]);
            }
            return values;
        },
        "fillDay": function() {
            var items = this.fillCommon("d"), name, i, twoDigit = this.options.template.indexOf("DD") !== -1, daysCount = 31;
            if (this.options.smartDays && this.$month && this.$year) {
                var month = parseInt(this.$month.val(), 10);
                var year = parseInt(this.$year.val(), 10);
                if (!isNaN(month) && !isNaN(year)) {
                    daysCount = moment([ year, month ]).daysInMonth();
                }
            }
            for (i = 1; i <= daysCount; i++) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        "fillMonth": function() {
            var items = this.fillCommon("M"), name, i, longNames = this.options.template.indexOf("MMMM") !== -1, shortNames = this.options.template.indexOf("MMM") !== -1, twoDigit = this.options.template.indexOf("MM") !== -1;
            for (i = 0; i <= 11; i++) {
                if (longNames) {
                    name = moment().date(1).month(i).format("MMMM");
                } else if (shortNames) {
                    name = moment().date(1).month(i).format("MMM");
                } else if (twoDigit) {
                    name = this.leadZero(i + 1);
                } else {
                    name = i + 1;
                }
                items.push([ i, name ]);
            }
            return items;
        },
        "fillYear": function() {
            var items = [], name, i, longNames = this.options.template.indexOf("YYYY") !== -1;
            for (i = this.options.maxYear; i >= this.options.minYear; i--) {
                name = longNames ? i : (i + "").substring(2);
                items[this.options.yearDescending ? "push" : "unshift"]([ i, name ]);
            }
            items = this.fillCommon("y").concat(items);
            return items;
        },
        "fillHour": function() {
            var items = this.fillCommon("h"), name, i, h12 = this.options.template.indexOf("h") !== -1, h24 = this.options.template.indexOf("H") !== -1, twoDigit = this.options.template.toLowerCase().indexOf("hh") !== -1, min = h12 ? 1 : 0, max = h12 ? 12 : 23;
            for (i = min; i <= max; i++) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        "fillMinute": function() {
            var items = this.fillCommon("m"), name, i, twoDigit = this.options.template.indexOf("mm") !== -1;
            for (i = 0; i <= 59; i += this.options.minuteStep) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        "fillSecond": function() {
            var items = this.fillCommon("s"), name, i, twoDigit = this.options.template.indexOf("ss") !== -1;
            for (i = 0; i <= 59; i += this.options.secondStep) {
                name = twoDigit ? this.leadZero(i) : i;
                items.push([ i, name ]);
            }
            return items;
        },
        "fillAmpm": function() {
            var ampmL = this.options.template.indexOf("a") !== -1, ampmU = this.options.template.indexOf("A") !== -1, items = [ [ "am", ampmL ? "am" : "AM" ], [ "pm", ampmL ? "pm" : "PM" ] ];
            return items;
        },
        "getValue": function(format) {
            var dt, values = {}, that = this, notSelected = false;
            angular.forEach(this.map, function(v, k) {
                if (k === "ampm") {
                    return;
                }
                var def = k === "day" ? 1 : 0;
                values[k] = that["$" + k] ? parseInt(that["$" + k].val(), 10) : def;
                if (isNaN(values[k])) {
                    notSelected = true;
                    return false;
                }
            });
            if (notSelected) {
                return "";
            }
            if (this.$ampm) {
                if (values.hour === 12) {
                    values.hour = this.$ampm.val() === "am" ? 0 : 12;
                } else {
                    values.hour = this.$ampm.val() === "am" ? values.hour : values.hour + 12;
                }
            }
            dt = moment([ values.year, values.month, values.day, values.hour, values.minute, values.second ]);
            this.highlight(dt);
            format = format === undefined ? this.options.format : format;
            if (format === null) {
                return dt.isValid() ? dt : null;
            } else {
                return dt.isValid() ? dt.format(format) : "";
            }
        },
        "setValue": function(value) {
            if (!value) {
                return;
            }
            var dt = typeof value === "string" ? moment(value, this.options.format, true) : moment(value), that = this, values = {};
            function getNearest($select, value) {
                var delta = {};
                angular.forEach($select.children("option"), function(opt, i) {
                    var optValue = angular.element(opt).attr("value");
                    if (optValue === "") return;
                    var distance = Math.abs(optValue - value);
                    if (typeof delta.distance === "undefined" || distance < delta.distance) {
                        delta = {
                            "value": optValue,
                            "distance": distance
                        };
                    }
                });
                return delta.value;
            }
            if (dt.isValid()) {
                angular.forEach(this.map, function(v, k) {
                    if (k === "ampm") {
                        return;
                    }
                    values[k] = dt[v[1]]();
                });
                if (this.$ampm) {
                    if (values.hour >= 12) {
                        values.ampm = "pm";
                        if (values.hour > 12) {
                            values.hour -= 12;
                        }
                    } else {
                        values.ampm = "am";
                        if (values.hour === 0) {
                            values.hour = 12;
                        }
                    }
                }
                angular.forEach(values, function(v, k) {
                    if (that["$" + k]) {
                        if (k === "minute" && that.options.minuteStep > 1 && that.options.roundTime) {
                            v = getNearest(that["$" + k], v);
                        }
                        if (k === "second" && that.options.secondStep > 1 && that.options.roundTime) {
                            v = getNearest(that["$" + k], v);
                        }
                        that["$" + k].val(v);
                    }
                });
                if (this.options.smartDays) {
                    this.fillCombo("day");
                }
                this.$element.val(dt.format(this.options.format)).triggerHandler("change");
            }
        },
        "highlight": function(dt) {
            if (!dt.isValid()) {
                if (this.options.errorClass) {
                    this.$widget.addClass(this.options.errorClass);
                } else {
                    if (!this.borderColor) {
                        this.borderColor = this.$widget.find("select").css("border-color");
                    }
                    this.$widget.find("select").css("border-color", "red");
                }
            } else {
                if (this.options.errorClass) {
                    this.$widget.removeClass(this.options.errorClass);
                } else {
                    this.$widget.find("select").css("border-color", this.borderColor);
                }
            }
        },
        "leadZero": function(v) {
            return v <= 9 ? "0" + v : v;
        },
        "destroy": function() {
            this.$widget.remove();
            this.$element.removeData("combodate").show();
        }
    };
    return {
        "getInstance": function(element, options) {
            return new Combodate(element, options);
        }
    };
} ]);

angular.module("xeditable").factory("editableIcons", function() {
    var icons = {
        "default": {
            "bs2": {
                "ok": "icon-ok icon-white",
                "cancel": "icon-remove",
                "clear": "icon-trash"
            },
            "bs3": {
                "ok": "glyphicon glyphicon-ok",
                "cancel": "glyphicon glyphicon-remove",
                "clear": "glyphicon glyphicon-trash"
            }
        },
        "external": {
            "font-awesome": {
                "ok": "fa fa-check",
                "cancel": "fa fa-times",
                "clear": "fa fa-trash"
            }
        }
    };
    return icons;
});

angular.module("xeditable").factory("editableThemes", function() {
    var themes = {
        "default": {
            "formTpl": '<form class="editable-wrap"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<span class="editable-controls"></span>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error" data-ng-if="$error" data-ng-bind="$error"></div>',
            "buttonsTpl": '<span class="editable-buttons"></span>',
            "submitTpl": '<button type="submit">save</button>',
            "cancelTpl": '<button type="button" ng-click="$form.$cancel()">cancel</button>',
            "resetTpl": '<button type="reset">clear</button>'
        },
        "bs2": {
            "formTpl": '<form class="form-inline editable-wrap" role="form"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error help-block" data-ng-if="$error" data-ng-bind="$error"></div>',
            "buttonsTpl": '<span class="editable-buttons"></span>',
            "submitTpl": '<button type="submit" class="btn btn-primary"><span></span></button>',
            "cancelTpl": '<button type="button" class="btn" ng-click="$form.$cancel()">' + "<span></span>" + "</button>",
            "resetTpl": '<button type="reset" class="btn btn-danger">clear</button>'
        },
        "bs3": {
            "formTpl": '<form class="form-inline editable-wrap" role="form"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error help-block" data-ng-if="$error" data-ng-bind="$error"></div>',
            "buttonsTpl": '<span class="editable-buttons"></span>',
            "submitTpl": '<button type="submit" class="btn btn-primary"><span></span></button>',
            "cancelTpl": '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">' + "<span></span>" + "</button>",
            "resetTpl": '<button type="reset" class="btn btn-danger">clear</button>',
            "buttonsClass": "",
            "inputClass": "",
            "postrender": function() {
                switch (this.directiveName) {
                  case "editableText":
                  case "editableSelect":
                  case "editableTextarea":
                  case "editableEmail":
                  case "editableTel":
                  case "editableNumber":
                  case "editableUrl":
                  case "editableSearch":
                  case "editableDate":
                  case "editableDatetime":
                  case "editableBsdate":
                  case "editableTime":
                  case "editableMonth":
                  case "editableWeek":
                  case "editablePassword":
                  case "editableDatetimeLocal":
                    this.inputEl.addClass("form-control");
                    if (this.theme.inputClass) {
                        if (this.inputEl.attr("multiple") && (this.theme.inputClass === "input-sm" || this.theme.inputClass === "input-lg")) {
                            break;
                        }
                        this.inputEl.addClass(this.theme.inputClass);
                    }
                    break;

                  case "editableCheckbox":
                    this.editorEl.addClass("checkbox");
                }
                if (this.buttonsEl && this.theme.buttonsClass) {
                    this.buttonsEl.find("button").addClass(this.theme.buttonsClass);
                }
            }
        },
        "semantic": {
            "formTpl": '<form class="editable-wrap ui form" ng-class="{\'error\': $error}" role="form"></form>',
            "noformTpl": '<span class="editable-wrap"></span>',
            "controlsTpl": '<div class="editable-controls ui fluid input" ng-class="{\'error\': $error}"></div>',
            "inputTpl": "",
            "errorTpl": '<div class="editable-error ui error message" data-ng-if="$error" data-ng-bind="$error"></div>',
            "buttonsTpl": '<span class="mini ui buttons"></span>',
            "submitTpl": '<button type="submit" class="ui primary button"><i class="ui check icon"></i></button>',
            "cancelTpl": '<button type="button" class="ui button" ng-click="$form.$cancel()">' + '<i class="ui cancel icon"></i>' + "</button>",
            "resetTpl": '<button type="reset" class="ui button">clear</button>'
        }
    };
    return themes;
});